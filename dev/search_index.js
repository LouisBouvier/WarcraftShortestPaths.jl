var documenterSearchIndex = {"docs":
[{"location":"","page":"Overview","title":"Overview","text":"CurrentModule = WarcraftShortestPaths","category":"page"},{"location":"#WarcraftShortestPaths","page":"Overview","title":"WarcraftShortestPaths","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Documentation for WarcraftShortestPaths.jl.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"This package implements techniques of machine learning for operations research to compute shortest paths  on Warcraft terrain images. It is one of the applications of our paper Learning with Combinatorial Optimization Layers: a Probabilistic Approach.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"This application was introduced in this paper, with the corresponding dataset and code. It was also considered in a Learning with Differentiable Perturbed Optimizers setting, with corresponding code.   ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"We focus on two main frameworks: learning by imitation, involving Fenchel-Young losses and perturbed maximizers, and learning  from experience. Both are based on the InferOpt.jl package. We also leverage  the GridGraphs.jl package to compute shortest paths on grid graphs using  Dijkstra algorithm.","category":"page"},{"location":"#Dataset-overview","page":"Overview","title":"Dataset overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Each point of the dataset is linked to a (12x12) Warcraft terrain grid. It is composed of:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"A color image of the Warcraft terrain of size (96x96).\nThe cost labels for the corresponding grid of size (12x12).\nA 0-1 shortest path mask of size (12x12).","category":"page"},{"location":"#Two-frameworks","page":"Overview","title":"Two frameworks","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The two distinct frameworks we consider are:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Learning by imitation: given the images and labels, learn the cost c_theta such that the labelled shortest paths are close to the shortest path computed with c_theta using Dijkstra on the Warcraft grids.\nLearning by experience: given the images and a black-box function that computes the cost of a path on any grid, learn the cost such that the true cost of the paths computed as shortest paths with respect to the learned costs are low.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"https://github.com/LouisBouvier/WarcraftShortestPaths.jl/blob/main/test/tutorial.jl\"","category":"page"},{"location":"tutorial/#Tutorial:-learning-by-experience","page":"Tutorial","title":"Tutorial: learning by experience","text":"","category":"section"},{"location":"tutorial/#Context","page":"Tutorial","title":"Context","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this tutorial page we illustrate one of the possible learning pipelines for the Warcraft shortest paths problem. We have a sub-dataset of Warcraft terrain images and corresponding black box cost functions. We want to learn the cost of the cells, using a neural network embedding. More precisely, each point in our dataset consists in:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"an image of terrain I.\na cost function c to evaluate any given path.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We don't know the true costs that were used to compute the shortest path, but we can exploit the images to approximate these costs. The question is: how should we combine these features? We use InferOpt to learn the appropriate costs, so that we may propose relevant paths in the future.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using WarcraftShortestPaths\nusing Graphs\nusing GridGraphs\nusing Flux\nusing InferOpt\nusing LinearAlgebra\nusing Random\nusing Statistics\nusing Test\nusing UnicodePlots\n\nRandom.seed!(63);\ndecompressed_path = joinpath(@__DIR__, \"..\",\"..\", \"data\", \"warcraft_maps\")","category":"page"},{"location":"tutorial/#Grid-graphs","page":"Tutorial","title":"Grid graphs","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For the purposes of this tutorial, we consider grid graphs, as implemented in GridGraphs.jl. In such graphs, each vertex corresponds to a couple of coordinates (i j), where 1 leq i leq h and 1 leq j leq w.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"h, w = 12, 12\ng = GridGraph(exp.(rand(h, w)));\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For convenience, GridGraphs.jl also provides custom functions to compute shortest paths efficiently. Let us see what those paths look like.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"p = path_to_matrix(g, grid_dijkstra(g, 1, nv(g)));\nspy(p)","category":"page"},{"location":"tutorial/#Learning-options","page":"Tutorial","title":"Learning options","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We first need to define a few learning options: the perturbation size ϵ, the number of noise sample per dataset point M, the number of training epochs nb_epochs, the number of dataset samples nb_samples, the batch size batch_size, and the starting learning rate lr_start.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"options = (ϵ=1.5, M=50, nb_epochs=100, dataset_size=100, batch_size = 80, lr_start = 0.001)","category":"page"},{"location":"tutorial/#Dataset-and-model","page":"Tutorial","title":"Dataset and model","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As announced, we do not know the cost of each vertex, only the image of the terrains. Let us load the dataset and keep 80% to train and 20% to test.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dataset = create_dataset(decompressed_path, options.dataset_size)\ntrain_dataset, test_dataset = train_test_split(dataset, 0.8)\nprintln(\"Size of the train dataset: $(size(train_dataset))\")\nprintln(\"Size of the test dataset: $(size(test_dataset))\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can have a glimpse at a dataset image as follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"x_test, y_test, kwargs_test = test_dataset[12]\nplot_map(dropdims(x_test; dims=4))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The corresponding shortest path:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot_path(y_test)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Our embedding is a truncated Resnet18.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"create_warcraft_embedding()","category":"page"},{"location":"tutorial/#Create-learning-pipeline-and-flux-loss","page":"Tutorial","title":"Create learning pipeline and flux loss","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here comes the specific InferOpt setting. We learn by experience here, only based on the images and on a black box cost function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"pipeline = (\n    encoder=create_warcraft_embedding(),\n    maximizer=identity,\n    loss=Pushforward(\n        PerturbedMultiplicative(true_maximizer; ε=options.ϵ, nb_samples=options.M), cost\n    )\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Define flux loss","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(; encoder, maximizer, loss) = pipeline\nflux_loss_point(x, y, kwargs) = loss(maximizer(encoder(x)); c_true = kwargs.wg.weights)\nflux_loss_batch(batch) = sum(flux_loss_point(item[1], item[2], item[3]) for item in batch)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We now have everything to train our model.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Losses, Cost_ratios = train_function!(;\n    encoder=encoder,\n    flux_loss = flux_loss_batch,\n    train_dataset=Flux.DataLoader(train_dataset; batchsize=options.batch_size),\n    test_dataset = Flux.DataLoader(test_dataset; batchsize=length(test_dataset)),\n    options=options,\n)","category":"page"},{"location":"tutorial/#Results","page":"Tutorial","title":"Results","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We are interested both in the loss and cost ratio between true and computed shortest path.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Gaps = Cost_ratios .- 1\nplot_loss_and_gap(Losses, Gaps, options)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To assess performance, we can compare the true and predicted paths.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"θ_test_pred =  encoder(x_test)\ny_test_pred = UInt8.(true_maximizer(θ_test_pred))\nplot_map(dropdims(x_test; dims=4))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The true cell costs:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot_weights(kwargs_test.wg.weights)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The predicted cell costs:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot_weights(-θ_test_pred)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The true shortest path:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot_path(y_test)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The predicted shortest path:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot_path(y_test_pred)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"API/","page":"API reference","title":"API reference","text":"CurrentModule = WarcraftShortestPaths","category":"page"},{"location":"API/#Documented-functions","page":"API reference","title":"Documented functions","text":"","category":"section"},{"location":"API/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"API/","page":"API reference","title":"API reference","text":"Modules = [WarcraftShortestPaths]","category":"page"},{"location":"API/#WarcraftShortestPaths.average_tensor-Tuple{Any}","page":"API reference","title":"WarcraftShortestPaths.average_tensor","text":"average_tensor(x)\n\nAverage the tensor x along its third axis.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.convert_image_for_plot-Tuple{Array{Float32, 3}}","page":"API reference","title":"WarcraftShortestPaths.convert_image_for_plot","text":"convert_image_for_plot(image::Array{Float32,3})::Array{RGB{N0f8},2}\n\nConvert image to the proper data format to enable plots in Julia.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.create_dataset","page":"API reference","title":"WarcraftShortestPaths.create_dataset","text":"create_dataset(decompressed_path::String, nb_samples::Int=10000)\n\nCreate the dataset corresponding to the data located at decompressed_path, possibly sub-sampling nb_samples points. The dataset is made of images of Warcraft terrains, cell cost labels and shortest path labels. It is a Vector of tuples, each Tuple being a dataset point.\n\n\n\n\n\n","category":"function"},{"location":"API/#WarcraftShortestPaths.create_warcraft_embedding-Tuple{}","page":"API reference","title":"WarcraftShortestPaths.create_warcraft_embedding","text":"create_warcraft_embedding()\n\nCreate and return a Flux.Chain embedding for the Warcraft terrains, inspired by differentiation of blackbox combinatorial solvers.\n\nThe embedding is made as follows:     1) The first 5 layers of ResNet18 (convolution, batch normalization, relu, maxpooling and first resnet block).     2) An adaptive maxpooling layer to get a (12x12x64) tensor per input image.     3) An average over the third axis (of size 64) to get a (12x12x1) tensor per input image.     4) The element-wize neg_exponential_tensor function to get cell weights of proper sign to apply shortest path algorithms.     4) A squeeze function to forget the two last dimensions. \n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.decompress_dataset-Tuple{String, String}","page":"API reference","title":"WarcraftShortestPaths.decompress_dataset","text":"decompress_dataset(compressed_path::String, decompressed_path::String)\n\nDecompress the dataset located at compressed_path and save it at decompressed_path.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.grid_bellman_ford_warcraft-Union{Tuple{A}, Tuple{W}, Tuple{R}, Tuple{T}, Tuple{GridGraphs.GridGraph{T, R, W, A}, Integer, Integer}, Tuple{GridGraphs.GridGraph{T, R, W, A}, Integer, Integer, Int64}} where {T, R, W, A}","page":"API reference","title":"WarcraftShortestPaths.grid_bellman_ford_warcraft","text":"grid_bellman_ford_warcraft(g, s, d, length_max)\n\nApply the Bellman-Ford algorithm on an GridGraph g, and return a ShortestPathTree with source s and destination d, among the paths having length smaller than length_max.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.neg_exponential_tensor-Tuple{Any}","page":"API reference","title":"WarcraftShortestPaths.neg_exponential_tensor","text":"neg_exponential_tensor(x)\n\nCompute minus exponential element-wise on tensor x.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.plot_image_and_path-Tuple{Matrix{ColorTypes.RGB{FixedPointNumbers.N0f8}}, Matrix{UInt8}}","page":"API reference","title":"WarcraftShortestPaths.plot_image_and_path","text":"plot_image_and_path(im::Array{RGB{N0f8}, 2}, zero_one_path::Matrix{UInt8})\n\nPlot the image im and the path zero_one_path on the same Figure.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.plot_image_label_path-Tuple{Matrix{ColorTypes.RGB{FixedPointNumbers.N0f8}}, Matrix{UInt8}, Matrix{UInt8}}","page":"API reference","title":"WarcraftShortestPaths.plot_image_label_path","text":"plot_image_label_path(im::Array{RGB{N0f8}, 2}, zero_one_path::Matrix{UInt8}, label::Matrix{UInt8})\n\nPlot the image im, the path zero_one_path and the labelled path label on the same Figure.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.plot_loss_and_gap-Tuple{Matrix{Float64}, Matrix{Float64}, NamedTuple}","page":"API reference","title":"WarcraftShortestPaths.plot_loss_and_gap","text":"plot_loss_and_gap(losses::Matrix{Float64}, gaps::Matrix{Float64},  options::NamedTuple; filepath=nothing)\n\nPlot the train and test losses, as well as the train and test gaps computed over epochs.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.plot_terrain_weights-Tuple{Matrix{Float16}, Matrix{Float32}}","page":"API reference","title":"WarcraftShortestPaths.plot_terrain_weights","text":"plot_terrain_weights(weights_label::Matrix{Float16}, computed_labels::Matrix{Float32})\n\nPlot both the cell costs labelled and computed on the same colormap Figure.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.read_dataset","page":"API reference","title":"WarcraftShortestPaths.read_dataset","text":"read_dataset(decompressed_path::String, dtype::String=\"train\")\n\nRead the dataset of type dtype at the decompressed_path location. The dataset is made of images of Warcraft terrains, cell cost labels and shortest path labels. They are returned separately, with proper axis permutation and image scaling to be consistent with  Flux embeddings.\n\n\n\n\n\n","category":"function"},{"location":"API/#WarcraftShortestPaths.save_metrics-Tuple{}","page":"API reference","title":"WarcraftShortestPaths.save_metrics","text":"save_metrics(;path::String,\n                losses::Matrix{Float64},\n                gaps::Matrix{Float64},\n\n)\n\nSave train and test losses and gaps tracked during training.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.shortest_path_cost_ratio-NTuple{4, Any}","page":"API reference","title":"WarcraftShortestPaths.shortest_path_cost_ratio","text":"shortest_path_cost_ratio(model, x, y, kwargs)\n\nCompute the ratio between the cost of the solution given by the model cell costs and the cost of the true solution. We evaluate both the shortest path with respect to the weights given by model(x) and the labelled shortest path y using the true cell costs stored in kwargs.wg.weights.  This ratio is by definition greater than one. The closer it is to one, the better is the solution given by the current  weights of model. We thus track this metric during training.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.shortest_path_cost_ratio-Tuple{Any, Any}","page":"API reference","title":"WarcraftShortestPaths.shortest_path_cost_ratio","text":"shortest_path_cost_ratio(model, batch)\n\nCompute the average cost ratio between computed and true shorest paths over batch. \n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.shortest_path_cost_ratio-Tuple{}","page":"API reference","title":"WarcraftShortestPaths.shortest_path_cost_ratio","text":"shortest_path_cost_ratio(;model, dataset)\n\nCompute the average cost ratio between computed and true shorest paths over dataset. \n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.squeeze_last_dims-Tuple{Any}","page":"API reference","title":"WarcraftShortestPaths.squeeze_last_dims","text":"squeeze_last_dims(x)\n\nSqueeze two last dimensions on tensor x.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.train_function!-Tuple{}","page":"API reference","title":"WarcraftShortestPaths.train_function!","text":"train_function!(;encoder, flux_loss, train_dataset, test_dataset, options::NamedTuple)\n\nTrain encoder model over train_dataset and test on test_dataset by minimizing flux_loss loss.  This training involves differentiation through argmax with perturbed maximizers, using InferOpt package. The task is to learn the best parameters for the encoder, so that when solving the shortest path problem with its output cell costs, the  given solution is close to the labelled shortest path corresponding to the input Warcraft terrain image. Hyperparameters are passed with options. During training, the average train and test losses are stored, as well as the average  cost ratio computed with shortest_path_cost_ratio both on the train and test datasets.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.train_test_split","page":"API reference","title":"WarcraftShortestPaths.train_test_split","text":"train_test_split(X::AbstractVector, train_percentage::Real=0.5)\n\nSplit a dataset contained in X into train and test datasets. The proportion of the initial dataset kept in the train set is train_percentage.\n\n\n\n\n\n","category":"function"},{"location":"API/#WarcraftShortestPaths.true_maximizer-Union{Tuple{AbstractMatrix{R}}, Tuple{R}} where R<:Real","page":"API reference","title":"WarcraftShortestPaths.true_maximizer","text":"true_maximizer(θ::AbstractMatrix{R}; kwargs...) where {R<:Real}\n\nCompute the shortest path from top-left corner to down-right corner on a gridgraph of the size of θ as an argmax. The weights of the arcs are given by the opposite of the values of θ related  to their destination nodes. We use GridGraphs, implemented  in GridGraphs.jl.\n\n\n\n\n\n","category":"method"}]
}
