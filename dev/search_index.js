var documenterSearchIndex = {"docs":
[{"location":"","page":"Overview","title":"Overview","text":"CurrentModule = WarcraftShortestPaths","category":"page"},{"location":"#WarcraftShortestPaths","page":"Overview","title":"WarcraftShortestPaths","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Documentation for WarcraftShortestPaths.jl.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"This package implements techniques of machine learning for operations research to compute shortest paths  on Warcraft terrain images. It is one of the applications of our paper Learning with Combinatorial Optimization Layers: a Probabilistic Approach.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"This application was introduced in this paper, with the corresponding dataset and code. It was also considered in a Learning with Differentiable Perturbed Optimizers setting, with corresponding code.   ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"We focus on two main frameworks: learning by imitation, involving Fenchel-Young losses and perturbed maximizers, and learning  from experience. Both are based on the InferOpt.jl package. We also leverage  the GridGraphs.jl package to compute shortest paths on grid graphs using  Dijkstra algorithm.","category":"page"},{"location":"#Dataset-overview","page":"Overview","title":"Dataset overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Each point of the dataset is linked to a (12x12) Warcraft terrain grid. It is composed of:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"A color image of the Warcraft terrain of size (96x96).\nThe cost labels for the corresponding grid of size (12x12).\nA 0-1 shortest path mask of size (12x12).","category":"page"},{"location":"#Two-frameworks","page":"Overview","title":"Two frameworks","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The two distinct frameworks we consider are:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Learning by imitation: given the images and labels, learn the cost c_theta such that the labelled shortest paths are close to the shortest path computed with c_theta using Dijkstra on the Warcraft grids.\nLearning by experience: given the images and a black-box function that computes the cost of a path on any grid, learn the cost such that the true cost of the paths computed as shortest paths with respect to the learned costs are low.","category":"page"},{"location":"API/","page":"API reference","title":"API reference","text":"CurrentModule = WarcraftShortestPaths","category":"page"},{"location":"API/#Documented-functions","page":"API reference","title":"Documented functions","text":"","category":"section"},{"location":"API/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"API/","page":"API reference","title":"API reference","text":"Modules = [WarcraftShortestPaths]","category":"page"},{"location":"API/#WarcraftShortestPaths.average_tensor-Tuple{Any}","page":"API reference","title":"WarcraftShortestPaths.average_tensor","text":"average_tensor(x)\n\nAverage the tensor x along its third axis.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.convert_image_for_plot-Tuple{Array{Float32, 3}}","page":"API reference","title":"WarcraftShortestPaths.convert_image_for_plot","text":"convert_image_for_plot(image::Array{Float32,3})::Array{RGB{N0f8},2}\n\nConvert image to the proper data format to enable plots in Julia.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.create_dataset","page":"API reference","title":"WarcraftShortestPaths.create_dataset","text":"create_dataset(decompressed_path::String, nb_samples::Int=10000)\n\nCreate the dataset corresponding to the data located at decompressed_path, possibly sub-sampling nb_samples points. The dataset is made of images of Warcraft terrains, cell cost labels and shortest path labels. It is a Vector of tuples, each Tuple being a dataset point.\n\n\n\n\n\n","category":"function"},{"location":"API/#WarcraftShortestPaths.create_warcraft_embedding-Tuple{}","page":"API reference","title":"WarcraftShortestPaths.create_warcraft_embedding","text":"create_warcraft_embedding()\n\nCreate and return a Flux.Chain embedding for the Warcraft terrains, inspired by differentiation of blackbox combinatorial solvers.\n\nThe embedding is made as follows:     1) The first 5 layers of ResNet18 (convolution, batch normalization, relu, maxpooling and first resnet block).     2) An adaptive maxpooling layer to get a (12x12x64) tensor per input image.     3) An average over the third axis (of size 64) to get a (12x12x1) tensor per input image.     4) The element-wize neg_exponential_tensor function to get cell weights of proper sign to apply shortest path algorithms.     4) A squeeze function to forget the two last dimensions. \n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.decompress_dataset-Tuple{String, String}","page":"API reference","title":"WarcraftShortestPaths.decompress_dataset","text":"decompress_dataset(compressed_path::String, decompressed_path::String)\n\nDecompress the dataset located at compressed_path and save it at decompressed_path.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.grid_bellman_ford_warcraft-Union{Tuple{A}, Tuple{W}, Tuple{R}, Tuple{T}, Tuple{GridGraphs.GridGraph{T, R, W, A}, Integer, Integer}, Tuple{GridGraphs.GridGraph{T, R, W, A}, Integer, Integer, Int64}} where {T, R, W, A}","page":"API reference","title":"WarcraftShortestPaths.grid_bellman_ford_warcraft","text":"grid_bellman_ford_warcraft(g, s, d, length_max)\n\nApply the Bellman-Ford algorithm on an GridGraph g, and return a ShortestPathTree with source s and destination d, among the paths having length smaller than length_max.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.neg_exponential_tensor-Tuple{Any}","page":"API reference","title":"WarcraftShortestPaths.neg_exponential_tensor","text":"neg_exponential_tensor(x)\n\nCompute minus exponential element-wise on tensor x.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.plot_image_and_path-Tuple{Matrix{ColorTypes.RGB{FixedPointNumbers.N0f8}}, Matrix{UInt8}}","page":"API reference","title":"WarcraftShortestPaths.plot_image_and_path","text":"plot_image_and_path(im::Array{RGB{N0f8}, 2}, zero_one_path::Matrix{UInt8})\n\nPlot the image im and the path zero_one_path on the same Figure.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.plot_image_label_path-Tuple{Matrix{ColorTypes.RGB{FixedPointNumbers.N0f8}}, Matrix{UInt8}, Matrix{UInt8}}","page":"API reference","title":"WarcraftShortestPaths.plot_image_label_path","text":"plot_image_label_path(im::Array{RGB{N0f8}, 2}, zero_one_path::Matrix{UInt8}, label::Matrix{UInt8})\n\nPlot the image im, the path zero_one_path and the labelled path label on the same Figure.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.plot_loss_and_gap-Tuple{Matrix{Float64}, Matrix{Float64}, NamedTuple}","page":"API reference","title":"WarcraftShortestPaths.plot_loss_and_gap","text":"plot_loss_and_gap(losses::Matrix{Float64}, gaps::Matrix{Float64},  options::NamedTuple; filepath=nothing)\n\nPlot the train and test losses, as well as the train and test gaps computed over epochs.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.plot_terrain_weights-Tuple{Matrix{Float16}, Matrix{Float32}}","page":"API reference","title":"WarcraftShortestPaths.plot_terrain_weights","text":"plot_terrain_weights(weights_label::Matrix{Float16}, computed_labels::Matrix{Float32})\n\nPlot both the cell costs labelled and computed on the same colormap Figure.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.read_dataset","page":"API reference","title":"WarcraftShortestPaths.read_dataset","text":"read_dataset(decompressed_path::String, dtype::String=\"train\")\n\nRead the dataset of type dtype at the decompressed_path location. The dataset is made of images of Warcraft terrains, cell cost labels and shortest path labels. They are returned separately, with proper axis permutation and image scaling to be consistent with  Flux embeddings.\n\n\n\n\n\n","category":"function"},{"location":"API/#WarcraftShortestPaths.save_metrics-Tuple{}","page":"API reference","title":"WarcraftShortestPaths.save_metrics","text":"save_metrics(;path::String,\n                losses::Matrix{Float64},\n                gaps::Matrix{Float64},\n\n)\n\nSave train and test losses and gaps tracked during training.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.shortest_path_cost_ratio-NTuple{4, Any}","page":"API reference","title":"WarcraftShortestPaths.shortest_path_cost_ratio","text":"shortest_path_cost_ratio(model, x, y, kwargs)\n\nCompute the ratio between the cost of the solution given by the model cell costs and the cost of the true solution. We evaluate both the shortest path with respect to the weights given by model(x) and the labelled shortest path y using the true cell costs stored in kwargs.wg.weights.  This ratio is by definition greater than one. The closer it is to one, the better is the solution given by the current  weights of model. We thus track this metric during training.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.shortest_path_cost_ratio-Tuple{Any, Any}","page":"API reference","title":"WarcraftShortestPaths.shortest_path_cost_ratio","text":"shortest_path_cost_ratio(model, batch)\n\nCompute the average cost ratio between computed and true shorest paths over batch. \n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.shortest_path_cost_ratio-Tuple{}","page":"API reference","title":"WarcraftShortestPaths.shortest_path_cost_ratio","text":"shortest_path_cost_ratio(;model, dataset)\n\nCompute the average cost ratio between computed and true shorest paths over dataset. \n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.squeeze_last_dims-Tuple{Any}","page":"API reference","title":"WarcraftShortestPaths.squeeze_last_dims","text":"squeeze_last_dims(x)\n\nSqueeze two last dimensions on tensor x.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.train_function!-Tuple{}","page":"API reference","title":"WarcraftShortestPaths.train_function!","text":"train_function!(;encoder, flux_loss, train_dataset, test_dataset, options::NamedTuple)\n\nTrain encoder model over train_dataset and test on test_dataset by minimizing flux_loss loss.  This training involves differentiation through argmax with perturbed maximizers, using InferOpt package. The task is to learn the best parameters for the encoder, so that when solving the shortest path problem with its output cell costs, the  given solution is close to the labelled shortest path corresponding to the input Warcraft terrain image. Hyperparameters are passed with options. During training, the average train and test losses are stored, as well as the average  cost ratio computed with shortest_path_cost_ratio both on the train and test datasets.\n\n\n\n\n\n","category":"method"},{"location":"API/#WarcraftShortestPaths.train_test_split","page":"API reference","title":"WarcraftShortestPaths.train_test_split","text":"train_test_split(X::AbstractVector, train_percentage::Real=0.5)\n\nSplit a dataset contained in X into train and test datasets. The proportion of the initial dataset kept in the train set is train_percentage.\n\n\n\n\n\n","category":"function"},{"location":"API/#WarcraftShortestPaths.true_maximizer-Union{Tuple{AbstractMatrix{R}}, Tuple{R}} where R<:Real","page":"API reference","title":"WarcraftShortestPaths.true_maximizer","text":"true_maximizer(θ::AbstractMatrix{R}; kwargs...) where {R<:Real}\n\nCompute the shortest path from top-left corner to down-right corner on a gridgraph of the size of θ as an argmax. The weights of the arcs are given by the opposite of the values of θ related  to their destination nodes. We use GridGraphs, implemented  in GridGraphs.jl.\n\n\n\n\n\n","category":"method"}]
}
